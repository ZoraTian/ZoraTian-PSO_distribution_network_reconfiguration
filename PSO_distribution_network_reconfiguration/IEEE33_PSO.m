%基于粒子群算法的IEEE33节点系统单时间段配网重构
clear 
clc
tic
warning off
T = 1;%时段数为1
nb = 33;%节点数,根节点为1
nl=37;%支路数
%% 粒子群算法
particleNumber = T*5*10; % 粒子数量，总共有5个变量，为断开支路的编号
variableNumber = T*(nl-nb+1); % 变量个数
c1 = 2;  % 个体加速常数
c2 = 2;  % 社会加速常数
w = 0.9;  % 惯性权重
iterationNumber = 20;  % 迭代的次数
vmax = 6*ones(1,variableNumber); % 粒子的最大速度
xmin = ones(1,variableNumber); % 断开支路的矩阵编号从1-37
x0=[10,6,4,8,8];%对应下面H矩阵的列数
% for i=1:24
%     xmax=[xmax,x0];
% end
xmax=[x0];
% H=[ 2	3	4	5	6	7	33	20	19	18	0	0	0	0	0	0	0	0	0	0	0
%     9	10	11	12	13	14	34	0	0	0	0	0	0	0	0	0	0	0	0	0	0
%     2	3	4	5	6	7	8	9	10	11	35	21	20	19	18	0	0	0	0	0	0
%     6	7	8	9	10	11	12	13	14	15	16	17	36	32	31	30	29	28	27	26	25
%     3	4	5	25	26	27	28	37	24	23	22	0	0	0	0	0	0	0	0	0	0];


% 初始化粒子位置
position = zeros(particleNumber, variableNumber);
% Z0=[33;34;35;36;37];
% Zij0 = kron(Z0,ones(1,24));
% for i = 1: particleNumber
%     position(i,:) = Zij0(:);  
% end
for i = 1: particleNumber
    for j=1:T
        position(i,(j-1)*5+1) = randi([1 10]);%对应H矩阵列数
        position(i,(j-1)*5+2) = randi([1 6]);
        position(i,(j-1)*5+3) = randi([1 4]);
        position(i,(j-1)*5+4) = randi([1 8]);
        position(i,(j-1)*5+5) = randi([1 8]);
    end
end


% 初始化粒子速度
v = (-vmax + 2*vmax .* rand(particleNumber,variableNumber));  %初始化粒子的速度
 
% 计算目标函数值
fit = zeros(particleNumber,1);                   % 初始化这n个粒子的适应度全为0
for i = 1:particleNumber                         % 循环整个粒子群，计算每一个粒子的适应度
    for j=1:T
        fit(i) = Target(position(i,(j-1)*5+1:j*5),j);           % 调用matpower工具箱计算适应度
    end
end 
bestPosition = position;                             % 初始化这n个粒子迄今为止找到的最佳位置
index = find(fit == min(fit), 1);               % 找到适应度最小的那个粒子的下标
z_result = position(index,:);                      % 定义所有粒子迄今为止找到的最佳位置
 

% 迭代K次来更新速度与位置
bestFit = ones(iterationNumber,1);  % 初始化每次迭代得到的最佳的适应度
for itor = 1:iterationNumber  % 开始迭代，一共迭代K次
    for i = 1:particleNumber   % 依次更新第i个粒子的速度与位置
        v(i,:) = (w*v(i,:) + c1*rand(1)*(bestPosition(i,:) - position(i,:)) + c2*rand(1)*(z_result - position(i,:)));  % 更新第i个粒子的速度
        % 粒子速度调整
        for j = 1: variableNumber
            if v(i,j) < -vmax(j)
                v(i,j) = -vmax(j);
            elseif v(i,j) > vmax(j)
                v(i,j) = vmax(j);
            end
        end
        position(i,:) = position(i,:) + v(i,:); % 更新第i个粒子的位置
        % 粒子位置调整
        for j = 1: variableNumber
            if position(i,j) < xmin(j)
                position(i,j) = xmin(j);
            elseif position(i,j) > xmax(j)
                position(i,j) = xmax(j);
            end
        end
        fit(i) = Target(position(i,:),1);         % 重新计算第i个粒子的适应度
        if fit(i) < Target(bestPosition(i,:),1)  
           bestPosition(i,:) = position(i,:);   % 更新第i个粒子找到的最佳位置
        end
        if  fit(i) < Target(z_result,1)            
            z_result = bestPosition(i,:);         % 那就更新所有粒子找到的最佳位置
        end
    end
    bestFit(itor) = Target(z_result,1);  % 更新第k次迭代得到的最佳的适应度
end
 
figure(1) 
plot(bestFit)  % 绘制出每次迭代最佳适应度的变化图
xlabel('迭代次数');
disp('最佳的位置是：'); disp(z_result)
disp('此时最优值是：'); disp(Target(z_result,1));


% 目标函数 求网损的最小值
function Ploss = Target(X,t) 
X=round(X);

H=[ 2	3	4	5	6	7	33	20	19	18	
    8	9	10	11	35	21	0	0	0	0	
    34	14	13	12	0	0	0	0	0	0	
    22	23	24	37	28	27	26	25	0	0	
    29	30	31	32	36	17	16	15	0	0  ];%环网编码规则，以每个环为基础，环间相同支路去除
%% 以下是matpower编写规则
DN.branch = [ 
	1	2	0.0922	0.0470	0	0	0	0	0	0	1	-360	360;
	2	3	0.4930	0.2511	0	0	0	0	0	0	1	-360	360;
	3	4	0.3660	0.1864	0	0	0	0	0	0	1	-360	360;
	4	5	0.3811	0.1941	0	0	0	0	0	0	1	-360	360;
	5	6	0.8190	0.7070	0	0	0	0	0	0	1	-360	360;
	6	7	0.1872	0.6188	0	0	0	0	0	0	1	-360	360;
	7	8	0.7114	0.2351	0	0	0	0	0	0	1	-360	360;
	8	9	1.0300	0.7400	0	0	0	0	0	0	1	-360	360;
	9	10	1.0440	0.7400	0	0	0	0	0	0	1	-360	360;
	10	11	0.1966	0.0650	0	0	0	0	0	0	1	-360	360;
	11	12	0.3744	0.1238	0	0	0	0	0	0	1	-360	360;
	12	13	1.4680	1.1550	0	0	0	0	0	0	1	-360	360;
	13	14	0.5416	0.7129	0	0	0	0	0	0	1	-360	360;
	14	15	0.5910	0.5260	0	0	0	0	0	0	1	-360	360;
	15	16	0.7463	0.5450	0	0	0	0	0	0	1	-360	360;
	16	17	1.2890	1.7210	0	0	0	0	0	0	1	-360	360;
	17	18	0.7320	0.5740	0	0	0	0	0	0	1	-360	360;
	2	19	0.1640	0.1565	0	0	0	0	0	0	1	-360	360;
	19	20	1.5042	1.3554	0	0	0	0	0	0	1	-360	360;
	20	21	0.4095	0.4784	0	0	0	0	0	0	1	-360	360;
	21	22	0.7089	0.9373	0	0	0	0	0	0	1	-360	360;
	3	23	0.4512	0.3083	0	0	0	0	0	0	1	-360	360;
	23	24	0.8980	0.7091	0	0	0	0	0	0	1	-360	360;
	24	25	0.8960	0.7011	0	0	0	0	0	0	1	-360	360;
	6	26	0.2030	0.1034	0	0	0	0	0	0	1	-360	360;
	26	27	0.2842	0.1447	0	0	0	0	0	0	1	-360	360;
	27	28	1.0590	0.9337	0	0	0	0	0	0	1	-360	360;
	28	29	0.8042	0.7006	0	0	0	0	0	0	1	-360	360;
	29	30	0.5075	0.2585	0	0	0	0	0	0	1	-360	360;
	30	31	0.9744	0.9630	0	0	0	0	0	0	1	-360	360;
	31	32	0.3105	0.3619	0	0	0	0	0	0	1	-360	360;
	32	33	0.3410	0.5302	0	0	0	0	0	0	1	-360	360;
    8	21	   2	   2	0	0	0	0	0	0	1	-360	360;
    9	15	   2	   2	0	0	0	0	0	0	1	-360	360;
    12	22	   2	   2	0	0	0	0	0	0	1	-360	360;
    18	33	   2	   2	0	0	0	0	0	0	1	-360	360;
    25	29	   2	   2	0	0	0	0	0	0	1	-360	360;
];       
DN.bus=[1, 3, 0, 0, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 1.05;
        2, 1, 0.100, 0.060, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        3, 1, 0.090, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        4, 1, 0.120, 0.080, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        5, 1, 0.060, 0.030, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        6, 1, 0.060, 0.020, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        7, 1, 0.200, 0.100, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        8, 1, 0.200, 0.100, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        9, 1, 0.060, 0.020, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        10, 1, 0.060, 0.020, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        11, 1, 0.045, 0.030, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        12, 1, 0.060, 0.035, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        13, 1, 0.060, 0.035, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        14, 1, 0.120, 0.080, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        15, 1, 0.060, 0.010, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        16, 1, 0.060, 0.020, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        17, 1, 0.060, 0.020, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        18, 1, 0.090, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        19, 1, 0.090, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        20, 1, 0.090, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        21, 1, 0.090, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        22, 1, 0.090, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        23, 1, 0.090, 0.050, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        24, 1, 0.420, 0.200, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        25, 1, 0.420, 0.200, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        26, 1, 0.060, 0.025, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        27, 1, 0.060, 0.025, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        28, 1, 0.060, 0.020, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        29, 1, 0.120, 0.070, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        30, 1, 0.200, 0.600, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        31, 1, 0.150, 0.070, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        32, 1, 0.210, 0.100, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95;
        33, 1, 0.060, 0.040, 0, 0, 1, 1, 0, 12.66, 1, 1.05, 0.95];
    
DN.gen=[1, 0, 0,10, -10, 1.05, 100, 1, 5, 0];
DN.branch(:,3)=DN.branch(:,3)*100/(12.66^2);
DN.branch(:,4)=DN.branch(:,4)*100/(12.66^2);
mpc = IEEE33BW;
pload = mpc.Pload;%节点有功负荷
pload=[pload(33,:);pload(1:32,:)];
qload = mpc.Qload;%节点无功负荷     
qload=[qload(33,:);qload(1:32,:)];
DN.baseMVA=100;
DN.bus(:,3)=pload(:,t)*100;
DN.bus(:,4)=qload(:,t)*100;

for i=1:5
    K(i)=H(i,X(i));
end
DN.branch(K,:)=[];%去掉断开支路

result=runpf23(DN);%matpower输出结果
if result.success==1
    Ploss=sum(result.branch(:,14)+result.branch(:,16))*100;%网损
else
    Ploss=5;
end
 

end
%%网损最优应该是2.61左右，粒子群求的是次优解，多次运行可得到最优解